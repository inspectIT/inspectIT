package rocks.inspectit.agent.java.instrumentation.asm;

import info.novatec.inspectit.org.objectweb.asm.ClassReader;
import info.novatec.inspectit.org.objectweb.asm.ClassWriter;

import com.google.common.base.Objects;

/**
 * Extension to the {@link ClassWriter} that has a specific class loader to use when resolving
 * common super class is called.
 * <p>
 * This was suggested by asm: http://mail-archive.ow2.org/asm/2008-08/msg00018.html.
 *
 * @author Ivan Senic
 *
 */
public class LoaderAwareClassWriter extends ClassWriter {

	/**
	 * {@link ClassLoader} to use when types need to be resolved.
	 */
	private final ClassLoader classLoader;

	/**
	 * Class being generated by this class writer.
	 */
	private String className;

	/**
	 * Defined super-class of the generated class.
	 */
	private String superClassName;

	/**
	 * Default constructor.
	 *
	 * @see ClassWriter#ClassWriter(ClassReader, int)
	 * @param classReader
	 *            the {@link ClassReader} used to read the original class. It will be used to copy
	 *            the entire constant pool from the original class and also to copy other fragments
	 *            of original bytecode where applicable.
	 * @param flags
	 *            option flags that can be used to modify the default behavior of this class. See
	 *            {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.
	 * @param classLoader
	 *            Class loader to be used in order to resolve the common super class. If
	 *            <code>null</code> is passed the default implementation of the {@link ClassWriter}
	 *            will be used (using Class.forName). If class loader is provided then this class
	 *            loader will be used in order to find required types.
	 */
	public LoaderAwareClassWriter(ClassReader classReader, int flags, ClassLoader classLoader) {
		super(classReader, flags);
		this.classLoader = classLoader;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected String getCommonSuperClass(String type1, String type2) {
		// if current type being generated is same as types we must not fire load of the same class
		if (Objects.equal(className, type1)) {
			// if we type2 is actually super class of generated type return it
			if (Objects.equal(superClassName, type2)) {
				return type2;
			} else {
				// otherwise use super class for resolving
				type1 = superClassName;
			}
		} else if (Objects.equal(className, type2)) {
			// if we type1 is actually super class of generated type return it
			if (Objects.equal(superClassName, type1)) {
				return type1;
			} else {
				// otherwise use super class for resolving
				type2 = superClassName;
			}
		}

		// if we don't have a class loader specified, just use super
		if (null == classLoader) {
			return super.getCommonSuperClass(type1, type2);
		}

		// otherwise use same code as in ClassWriter, but with provided class loader
		Class<?> c, d;
		try {
			c = Class.forName(AsmUtil.getFqn(type1), false, classLoader);
			d = Class.forName(AsmUtil.getFqn(type2), false, classLoader);
		} catch (Exception e) {
			throw new RuntimeException(e.toString(), e);
		}
		if (c.isAssignableFrom(d)) {
			return type1;
		}
		if (d.isAssignableFrom(c)) {
			return type2;
		}
		if (c.isInterface() || d.isInterface()) {
			return "java/lang/Object";
		} else {
			do {
				c = c.getSuperclass();
			} while (!c.isAssignableFrom(d));
			return AsmUtil.getAsmInternalName(c.getName());
		}
	};

	/**
	 * Sets {@link #className}.
	 *
	 * @param className
	 *            New value for {@link #className}
	 */
	public void setClassName(String className) {
		this.className = className;
	}

	/**
	 * Sets {@link #superClassName}.
	 *
	 * @param superClassName
	 *            New value for {@link #superClassName}
	 */
	public void setSuperClassName(String superClassName) {
		this.superClassName = superClassName;
	}

}
